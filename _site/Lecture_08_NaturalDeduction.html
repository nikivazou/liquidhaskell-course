<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Liquid Haskell</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Lecture_01_RefinementTypes.html'><b>1.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.1.</b> Installation</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.2.</b> Basic Refinement Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.3.</b> Subtyping</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.4.</b> From Subtyping to Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.5.</b> Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.6.</b> Primitive Operations</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.7.</b> Function Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.8.</b> Branching and Recursion</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.9.</b> Refined Polymorphism</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.10.</b> Putting it all together: Safe Indexing</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.11.</b> Summary</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.12.</b> Further Reading</a></li>
</ul>
<li><a href='Lecture_02_DataTypes.html'><b>2.</b>Data Types</a></li>
<ul class='section'>
<li><a href='Lecture_02_DataTypes.html#'><b>2.1.</b> Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.2.</b> Multiple Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.3.</b> Recursive Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.4.</b> Higher-Order Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.5.</b> Folding (Indexed Lists)</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.6.</b> Data Invariants: Sparse Vectors</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.7.</b> Ordered Lists</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_03_Sortedness.html'><b>3.</b>Sortedness &amp; Abstract Refinements</a></li>
<ul class='section'>
<li><a href='Lecture_03_Sortedness.html#'><b>3.1.</b> Ordered Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.2.</b> Abstraction over Sortedness</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.3.</b> Haskell's Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.4.</b> Dependent Pairs</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_04_Termination.html'><b>4.</b>Termination</a></li>
<ul class='section'>
<li><a href='Lecture_04_Termination.html#'><b>4.1.</b> Termination Requires Refinements!</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.2.</b> Termination Metrics</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.3.</b> Lexicographic Termination</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.4.</b> The GCD Example</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.5.</b> Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.6.</b> User Defined Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.7.</b> Mutual Recursion</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_05_ProofsPrograms.html'><b>5.</b>Programs are Proofs</a></li>
<ul class='section'>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.1.</b> Each Program Proves its type</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.2.</b> Propositions as Refinement Types</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.3.</b> Quantified Theorems</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.4.</b> Theorems about Haskell Functions</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.5.</b> Reusing Proofs, the "because" combinator</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.6.</b> Quantified Proofs</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.7.</b> Monotonicity of the Fibonacci Function</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.8.</b> Generalizing the Monotonicity Proof</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.9.</b> Proofs By Natural Induction</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.10.</b> Summary</a></li>
</ul>
<li><a href='Lecture_06_StructuralInduction.html'><b>6.</b>Structural Induction</a></li>
<ul class='section'>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.1.</b> Structural Induction on Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.2.</b> Map Fusion</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.3.</b> Monoid Laws for Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.4.</b> Using Proved Lemma</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_07_CaseStudyMapReduce.html'><b>7.</b>Case Study: Map Reduce</a></li>
<ul class='section'>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.1.</b> Map Reduce Explained</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.2.</b> Map Reduce "Library" Functions:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.3.</b> Map Reduce "Client" Functions: Summing a List</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.4.</b> Proving Code Equivalence: <code>sum</code> and <code>psum</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.5.</b> Chunk Definition:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.6.</b> Higher Order Theorem: <code>mRTheorem</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.7.</b> Lemmata for <code>mRTheorem</code> on plus</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.8.</b> Summary</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.9.</b> Appendix: List Manipulation Functions</a></li>
</ul>
<li><a href='Lecture_08_NaturalDeduction.html'><b>8.</b>Natural Deduction</a></li>
<ul class='section'>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.1.</b> Logical Properties</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.2.</b> Native Terms</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.3.</b> Conjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.4.</b> Disjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.5.</b> Implication &amp; Negation</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.6.</b> Forall and Exists</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.7.</b> Examples</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_09_DataPropositions.html'><b>9.</b>Data Propositions</a></li>
<ul class='section'>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.1.</b> Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.2.</b> Construction of Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.3.</b> Functions on Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.4.</b> Metatheory of Programming Languages</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.5.</b> Evaluation of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.6.</b> Typing of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.7.</b> Soundness = Progress + Preservation</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.8.</b> Summary</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.9.</b> Appendix: The rest of the Code</a></li>
</ul>
<li><a href='Task1.html'><b>10.</b>Task 1: Program Verification</a></li>
<ul class='section'>
</ul>
<li><a href='Task1.pretty.html'><b>11.</b>Task 1: Program Verification</a></li>
<ul class='section'>
<li><a href='Task1.pretty.html#'><b>11.1.</b> 1. Lists</a></li>
<li><a href='Task1.pretty.html#'><b>11.2.</b> 2. Insertion Sort</a></li>
<li><a href='Task1.pretty.html#'><b>11.3.</b> 3. Merge Sort</a></li>
</ul>
<li><a href='Task1All.html'><b>12.</b>Task 1: Program Verification</a></li>
<ul class='section'>
</ul>
<li><a href='Task2.html'><b>13.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2.html#'><b>13.1.</b> 1. Fusions</a></li>
</ul>
<li><a href='Task2.pretty.html'><b>14.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2.pretty.html#'><b>14.1.</b> 1. Fusions</a></li>
<li><a href='Task2.pretty.html#'><b>14.2.</b> 2. Higher Order Properties</a></li>
<li><a href='Task2.pretty.html#'><b>14.3.</b> 3. Encoding of Logical Properties</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="natural-deduction" class="level1">
<h1>Natural Deduction</h1>
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{- OPTIONS_GHC -fplugin=LiquidHaskell #-}
module Lecture_08_NaturalDeduction where

{-@ LIQUID "--reflection" @-}
{-@ LIQUID "--ple"        @-}
{-@ infix ++ @-}
import Language.Haskell.Liquid.ProofCombinators
import Prelude hiding ((++))</div>
</div>

<p>In a previous lecture we saw tha programs are proofs and we proved a higher order property, i.e., a property over functions, that all increasing functions are monotonic.</p>
<p>In this lecture, we see that <em>any</em> higher order property can be encoded in Liquid Haskell, because refinement types can encode higher order logic and type checking can encode the natural deduction proof system.</p>
<section id="logical-properties" class="level2">
<h2>Logical Properties</h2>
<p>Like a programming language, logic has</p>
<ul>
<li><strong>syntax</strong> (<span class="math inline">\(e\)</span>, <span class="math inline">\(\land\)</span>, <span class="math inline">\(\lor\)</span>, <span class="math inline">\(\lnot\)</span>, <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\forall\)</span>, <span class="math inline">\(\exists\)</span>)</li>
<li><strong>meaning</strong> (if <span class="math inline">\(\phi\)</span> is true and <span class="math inline">\(\psi\)</span> is true, then <span class="math inline">\(\phi \land \psi\)</span> is true), and</li>
<li><strong>“evaluation”</strong> (decision procedues).</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Natural_deduction"><strong>Natural Deduction</strong></a> is a decision procedure for logic. The Curry-Howard correspondence says that propositions are types and proofs are programs. In this lecture, we will see that natural deduction is encoded by type checking rules.</p>
<p>Concretely, we will see the encoding by filling in the following table:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="native-terms" class="level2">
<h2>Native Terms</h2>
<p>We start with the simplest case, native terms. We have already seen that native terms are encoded by refinements on unit types:</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">{-@ fact1 :: {v:() | 2 == 1 + 1 } @-}
fact1 :: ()
fact1 = ()

{-@ fact2 :: {v:() | 2 /= 3 } @-}
fact2 :: ()
fact2 = ()</div>
</div>

<p>So native terms are encoded by unit types with refinements:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{v:() | e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="conjunction" class="level2">
<h2>Conjunction</h2>
<p>Conjunction is encoded by the pair type. If you know that <span class="math inline">\(\phi_1\)</span> is true and <span class="math inline">\(\phi_2\)</span> is true, then <span class="math inline">\((\phi_1, \phi_2)\)</span> is a term that shows that <span class="math inline">\(\phi_1 \land \phi_2\)</span> is true.</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ conj :: ϕ1:{Bool | ϕ1 } -> ϕ2:{Bool | ϕ2 } 
         -> {v:(Bool, Bool) | ϕ1 && ϕ2} @-}
conj :: Bool -> Bool -> (Bool, Bool)
conj ϕ1 ϕ2 = (ϕ1,ϕ2)</div>
</div>

<p><strong>Deduction Rules:</strong> The rules of natural deduction are the rules that we can use to prove a formula. For conjuctions, there are three rules:</p>
<ul>
<li>left and right <em>elimination</em>, eliminates the conjunction and</li>
<li><em>introduction</em>, introduces the conjunction.</li>
</ul>
<p>These rules are part of the natural deduction proof system and can also be encoded as refinement type checking rules.</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 40%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Rule</th>
<th style="text-align: center;"><strong>Natural Deduction</strong></th>
<th style="text-align: center;"><strong>Type Checking</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Left Elimination</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \phi_1 \land \phi_2  }{  \Gamma \vdash \phi_1  }\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e : (\phi_1, \phi_2)  }{  \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_1 : \phi_1  }\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Right Elimination</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \phi_1 \land \phi_2  }{  \Gamma \vdash \phi_2  }\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e : (\phi_1, \phi_2)  }{  \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_2 : \phi_2  }\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Introduction</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \phi_1  \\  \Gamma \vdash \phi_2  }{  \Gamma \vdash \phi_1 \land \phi_2  }\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_1 : \phi_1  \\  \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_2 : \phi_2  }{  \Gamma \vdash e : (\phi_1, \phi_2)  }\)</span></td>
</tr>
</tbody>
</table>
<p>The type checking rules are not part of the core rules (that we saw in the first lecture), but they can be derived from the core rules.</p>
<p>If we ignore the expressions in the type checking rules, we take exactly the conjuction rules of natural deduction.</p>
<p><strong>You can generate Haskell terms that provide evidence for the natural deduction rules!</strong></p>
<p><strong>As an example,</strong> consider the logical formula:</p>
<p><span class="math display">\[ \textit{If } \phi_1 \textit{ and } \phi_2\land\phi_3, \text{ then }  \phi_1\land \phi_3 .\]</span></p>
<p>The natural deduction devation tree is shown below:</p>
<p><span class="math display">\[
\inferrule
  {\land\text{-I}}
  {
    \phi_1,\phi_2\land\phi_3 \vdash  \phi_1  \qquad
    \inferrule{\land\text{-R-E}}
    {
      \phi_1,\phi_2\land\phi_3 \vdash  \phi_2\land\phi_3
    }{
      \phi_1,\phi_2\land\phi_3 \vdash  \phi_3
    }
  }{
    \phi_1, \phi_2\land\phi_3 \vdash  \phi_1\land \phi_3
  }
\]</span></p>
<p>Filling in the terms (and applying the correspondence of propositions and types) we get the type checking derivation tree:</p>
<p><span class="math display">\[
\inferrule
  {\land\text{-I}}
  {
    x_1:\phi_1,x_{23}:\phi_2\land\phi_3 \vdash  x_1:\phi_1  \qquad
    \inferrule{\land\text{-R-E}}
    {
      x_1:\phi_1,x_{23}:\phi_2\land\phi_3 \vdash x_{23}: \phi_2\land\phi_3
    }{
      x_1:\phi_1,x_{23}:\phi_2\land\phi_3 \vdash \text{case } x_{23} \text{ of } (x_2, x_3) \rightarrow x_3: \phi_3
    }
  }{
    x_1:\phi_1,x_{23}: \phi_2\land\phi_3 \vdash (x_1, \text{case } x_{23} \text{ of } (x_2, x_3) \rightarrow x_3): \phi_1\land \phi_3
  }
\]</span></p>
<ul>
<li><strong>Example 1: Conjunction</strong></li>
</ul>
<p>Let’s encode this proof in Liquid Haskell!</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">{-@ ex1 :: φ1:Bool -> φ2:Bool -> φ3:Bool 
        -> {v:() | φ1}
        -> ({v:() | φ2}, {v:() | φ3})
        -> ({v:() | φ1}, {v:() | φ3}) @-}
ex1 :: Bool -> Bool -> Bool -> () -> ((), ()) -> ((), ())
ex1 _ _ _ x1 x23 = 
  (x1, case x23 of (x2,x3) -> x3)</div>
</div>

<p>So, conjuction is encoded by the pair type.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{v:() | e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="disjunction" class="level2">
<h2>Disjunction</h2>
<p>Disjunction is encoded by the <code>Either</code> type, which is a sum type that can be either <code>Left</code> or <code>Right</code>.</p>
<pre class="spec"><code>data Either a b = Left a | Right b -- defined in Prelude</code></pre>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">{-@ disj :: ϕ1:Bool -> ϕ2:Bool -> {v:() | ϕ1 || ϕ2 }
         -> Either {v:() | ϕ1} {v:() | ϕ2} @-}
disj :: Bool -> Bool -> () -> Either () ()
disj ϕ1 ϕ2 p = if ϕ1 then Left p else Right p</div>
</div>

<p>If you know that <span class="math inline">\(\phi_1\)</span> is true or <span class="math inline">\(\phi_2\)</span> is true, then <code>Left ()</code> is a term that shows that <span class="math inline">\(\phi_1 \lor \phi_2\)</span> is true and <code>Right ()</code> is a term that shows that <span class="math inline">\(\phi_1 \lor \phi_2\)</span> is true.</p>
<p><strong>Deduction Rules:</strong> Dually to conjunction, disjunction has three rules: left and right <em>introduction</em> and <em>elimination</em>.</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 40%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Rule</th>
<th style="text-align: center;"><strong>Natural Deduction</strong></th>
<th style="text-align: center;"><strong>Type Checking</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Left Introduction</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}{ \Gamma \vdash \phi_1}{\Gamma \vdash \phi_1 \lor \phi_2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e : \phi_1  }{  \Gamma \vdash \text{Left } e : \text{Either } \phi_1 \ \phi_2  }\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Right Introduction</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}{ \Gamma \vdash \phi_2}{\Gamma \vdash \phi_1 \lor \phi_2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e : \phi_2  }{  \Gamma \vdash \text{Right } e : \text{Either } \phi_1 \ \phi_2  }\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Elimination</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \phi_1 \lor \phi_2  \\  \Gamma, \phi_1 \vdash \phi  \\  \Gamma, \phi_2 \vdash \phi  }{  \Gamma \vdash \phi  }\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e : \text{Either } \phi_1\ \phi_2 \\  \Gamma, x_1 : \phi_1 \vdash e_1 : \phi \\  \Gamma, x_2 : \phi_2 \vdash e_2 : \phi  }{  \Gamma \vdash \text{case } e \text{ of } \{\text{Left } x_1 \rightarrow x_1 ;  \text{Right } x_2 \rightarrow x_2 \} : \phi  }\)</span></td>
</tr>
</tbody>
</table>
<p>So, disjunction is encoded by the either type.</p>
<ul>
<li><strong>Example 2: Disjunction</strong></li>
</ul>
<p>Consider the valid logical formula: <span class="math display">\[ \textit{If } \phi \lor \text{ false,} \textit{ then }  \phi .\]</span></p>
<p>In Liquid Haskell, it is encoded usint the below type specification:</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">{-@ exOr :: ϕ:Bool -> Either {v:() | ϕ} {v:() | false }
         -> {v:() | ϕ}  @-}
exOr :: Bool -> Either () () -> ()
exOr φ p = undefined </div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>exOr</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>exOr ϕ (Left p)  = p
exOr ϕ (Right p) = error &quot;impossible&quot;</code></pre>
</details>
<p>So, disjunction is encoded by the either type:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{v:() | e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;">Either <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="implication-negation" class="level2">
<h2>Implication &amp; Negation</h2>
<p><strong>Implication</strong> is encoded by the function type. It has two rules: <em>introduction</em> and <em>elimination</em>:</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 40%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Rule</th>
<th style="text-align: center;"><strong>Natural Deduction</strong></th>
<th style="text-align: center;"><strong>Type Checking</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Introduction</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}{ \Gamma, \phi_x \vdash \phi}{\Gamma \vdash \phi_x \Rightarrow \phi}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma, x : \phi_x \vdash e : \phi  }{  \Gamma \vdash \lambda x. e : \phi_x \rightarrow \phi  }\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Elimination</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \phi_x  \\  \Gamma \vdash \phi_x \Rightarrow \phi  }{  \Gamma \vdash \phi  }\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e_x : \phi_x  \\  \Gamma \vdash e : (\phi_x \rightarrow \phi)  }{  \Gamma \vdash e\ e_x : \phi  }\)</span></td>
</tr>
</tbody>
</table>
<p>The Implication Elimination Rule for natural deduction is also known as the <em>modus ponens</em> rule.</p>
<p><strong>Negation</strong> is just implication to <code>False</code>.</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">{-@ neg :: ϕ:Bool -> {v:() | not ϕ} 
        -> ({v:() | ϕ} -> {v:() | false}) @-}
neg :: Bool -> () -> (() -> ())
neg _ _ = \_ -> ()</div>
</div>

<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{v:() | e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;">Either <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \rightarrow \phi_2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi \rightarrow \{\text{false}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Example 3: Contradictions</strong></li>
</ul>
<p>Consider the valid logical formula: <span class="math display">\[ \phi_C \doteq  \lnot \phi \land \phi \Rightarrow \text{false}\]</span></p>
In Liquid Haskell, it is encoded usint the below type specification:
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ exC :: φ:Bool 
        -> (({v:() | φ} -> {v:() | false}), {v:() | φ}) 
        -> {v:() | false} @-}
exC :: Bool ->  (() -> () , ()) -> ()
exC ϕ p = undefined </div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>exC</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>exC ϕ (f, p) = f p </code></pre>
</details>
<ul>
<li><strong>Example 4: Double Negation</strong></li>
</ul>
<p>Consider the valid logical formula:</p>
<p><span class="math display">\[ \phi_{DN} \doteq  \lnot \lnot \phi \Rightarrow \phi\]</span></p>
In Liquid Haskell, it is encoded usint the below type specification:
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ exDN :: φ:Bool 
         -> (({v:() | φ} -> {v:() | false}) -> {v:() | false}) 
         -> {v:() | φ}  @-}
exDN :: Bool -> ((()-> ()) -> ()) -> () 
exDN ϕ nnp = undefined </div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>exDN</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>exDN ϕ nnp | not ϕ = nnp f 
  where 
    {-@ f :: {v:() | not ϕ &amp;&amp; ϕ} -&gt; {v:() | false} @-} 
    f :: () -&gt; () 
    f _ = () 
exDN ϕ nnp = ()</code></pre>
</details>
</section>
<section id="forall-and-exists" class="level2">
<h2>Forall and Exists</h2>
<p><strong>Universal quantification</strong> is encoded by the function type. It has two rules: <em>introduction</em> and <em>elimination</em>:</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 40%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Rule</th>
<th style="text-align: center;"><strong>Natural Deduction</strong></th>
<th style="text-align: center;"><strong>Type Checking</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Introduction</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}{ \Gamma \vdash \phi_x}{\Gamma \vdash \forall x. \phi_x}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma, x:\tau \vdash e : \phi_x  }{  \Gamma \vdash \lambda x. e : x:\tau \rightarrow \phi_x  }\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Elimination</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \forall x. \phi_x  }{  \Gamma \vdash \phi_x [x / e_x]  }\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e : (x:\tau \rightarrow \phi_x) \quad  \Gamma \vdash e_x : \tau  }{  \Gamma \vdash e\ e_x : \phi_x [x / e_x]  }\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Existsential quantification</strong> is encoded by the dependent pair type. It has two rules: <em>introduction</em> and <em>elimination</em>:</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 40%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Rule</th>
<th style="text-align: center;"><strong>Natural Deduction</strong></th>
<th style="text-align: center;"><strong>Type Checking</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Introduction</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}{ \Gamma \vdash \phi_x[x / e_x]}{\Gamma \vdash \exists x. \phi_x}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \text{fst } e : \tau \quad  \Gamma, x:\tau \vdash \text{snd } e : \phi_x  }{  \Gamma \vdash e : (x:\tau, \phi_x[x / \text{fst } e])  }\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Elimination</td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash \exists x. \phi_x  \\  \Gamma, \phi_x[x / e_x] \vdash \phi  }{  \Gamma \vdash : \phi  }\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\inferrule{}  {  \Gamma \vdash e : (x:\tau, \phi_x) \\  \Gamma, x:\tau, y:\phi_x \vdash e&#39; : \phi  }{  \Gamma \vdash \text{case } e \text{ of } (x, y) \rightarrow e&#39; : \phi  }\)</span></td>
</tr>
</tbody>
</table>
<p>These concludes the encoding of the rules of natural deduction in refinement types:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{v:() | e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;">Either <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \rightarrow \phi_2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi \rightarrow \{\text{false}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x:\tau \rightarrow \phi\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\((x:\tau, \phi)\)</span></td>
</tr>
</tbody>
</table>
<p>Let’s now see some examples that use it!</p>
</section>
<section id="examples" class="level2">
<h2>Examples</h2>
<ul>
<li><strong>Example 4: ExistsAll</strong></li>
</ul>
<p>This example encodes a proof that if there exists an <span class="math inline">\(x\)</span> that satisfies a property forall <span class="math inline">\(y\)</span>, then forall <span class="math inline">\(y\)</span> there exists an <span class="math inline">\(x\)</span> that satisfies the property.</p>
<p><span class="math display">\[ \phi \doteq \exists x. \forall y. p\ x \ y  \Rightarrow \forall y. \exists x. p \ x \ y \]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">{-@ exAll :: p:(a -> a -> Bool)
          -> (x::a, y:a -> {v:() | p x y}) 
          -> y:a 
          -> (x::a, {v:() | p x y}) @-}
exAll :: (a -> a -> Bool) -> (a, a -> ()) -> a -> (a, ())
exAll p = undefined</div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>exAll</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>exAll p (x, f) y = (x, f y)</code></pre>
</details>
<p>The natural deduction proof is shown below:</p>
<div id="fig:avl" style="align: left; text-align:center;">
  <img src="img/exAll.png" height="300px" style="display:block;  margin-left:auto; margin-right:auto">
  <div class="caption" style="text-align:center"><b>Figure 1.1:</b> Natural Deduction Proof for exAll </div>
</div>
<br>


<ul>
<li><strong>Example 5: Distributing Qualifiers</strong></li>
</ul>
<p>First, let’s distribute the exists quantifier over disjunction.</p>
<p><span class="math display">\[ \phi_\exists = (\exists x. p\ x \lor q\ x) \rightarrow ((\exists x. p\ x) \lor (\exists x. q\ x)) \]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">exDistOr = undefined </div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>exDistOr</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>{-@ exDistOr :: p:(a -&gt; Bool) -&gt; q:(a -&gt; Bool)
             -&gt; (x::a, Either {v:() | p x} {v:() | q x})
             -&gt; Either (x::a, {v:() | p x}) (x::a, {v:() | q x}) @-}
exDistOr :: (a -&gt; Bool) -&gt; (a -&gt; Bool)
         -&gt; (a, Either () ())
         -&gt; Either (a,()) (a,())
exDistOr p q (x, Left f) = Left (x, f )
exDistOr p q (x, Right g) = Right (x, g )</code></pre>
</details>
<p>Now, let’s distribute the forall quantifier over conjunction.</p>
<p><span class="math display">\[ \phi_\forall = (\forall x. p\ x \land q\ x) \rightarrow ((\forall x. p\ x) \land (\forall x. q\ x))\]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">allDistAnd = undefined</div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>allDistAnd</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>{-@ allDistAnd :: p:(a -&gt; Bool) -&gt; q:(a -&gt; Bool)
               -&gt; (x:a -&gt; ({v:() | p x}, {v:() | q x}))
               -&gt; (x:a -&gt; {v:() | p x}, x:a -&gt; {v:() | q x}) @-}
allDistAnd :: (a -&gt; Bool) -&gt; (a -&gt; Bool)
          -&gt; (a -&gt; ((), ()))
          -&gt; (a -&gt; (), a -&gt; ())

allDistAnd p q xpq = (\x -&gt; case xpq x of (p,_) -&gt; p, 
                      \x -&gt; case xpq x of (_,q) -&gt; q)</code></pre>
</details>
<ul>
<li><strong>Example 6: List Properties</strong></li>
</ul>
<p>Next, let’s prove that for all lists that are constructed by appending a list to itself, there exists an integer that is half the length of the list.</p>
<p><span class="math display">\[ \phi = \forall xs. (\exists ys. xs = ys \text{ ++ } ys) \rightarrow (\exists n. \text{length } xs = n + n )\]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">evenLen = undefined</div>
</div>

<p><strong>Question</strong>: Can you prove the above property in Liquid Haskell? <em>Hint:</em> You can use the property <code>lenAppend</code>:</p>
<div id="program-pane-13" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-13" class="programbox">{-@ lenAppend :: xs:[a] -> ys:[a] -> {v:() | len (xs ++ ys) == len xs + len ys} @-}
lenAppend :: [a] -> [a] -> ()
lenAppend [] _      = ()
lenAppend (_:xs) ys = lenAppend xs ys

{-@ reflect ++ @-}
(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)</div>
</div>

<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>evenLen</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>{-@ evenLen :: xs:[a] -&gt; (ys::[a], {v:() | xs == ys ++ ys})
            -&gt; (n::{v:Int | 0 &lt;= v}, {v:() | len xs == n + n}) @-}
evenLen :: [a] -&gt; ([a], ()) -&gt; (Int, ())
evenLen xs (ys, ()) = (length ys, lenAppend ys ys)</code></pre>
</details>
<ul>
<li><strong>Example 7: Natural Induction</strong></li>
</ul>
<p>Finally, let’s prove that for all natural numbers,</p>
<p><span class="math display">\[ \phi = (p \ 0 \land (\forall n. p \ (n-1) \rightarrow p \ n))) \rightarrow \forall n. p \ n\]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-14" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-14" class="programbox">natInd = undefined</div>
</div>

<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>natInd</code> can be defined as follows:</em>
</p>
<pre class="spec"><code>{-@ natInd :: p:({v:Int | 0 &lt;= v} -&gt; Bool)
           -&gt; ({v:() | p 0}, n:{v:Int | 0 &lt;= v} -&gt; {v:() | p (n-1)} -&gt; {v:() | p n})
           -&gt; n:{v:Int | 0 &lt;= v} -&gt; {v:() | p n} / [n] @-}
natInd :: (Int -&gt; Bool) -&gt; ((), Int -&gt; () -&gt; ()) -&gt; Int -&gt; () 
natInd p (p0, pn) n 
  = if n == 0 then p0 else pn n (natInd p (p0, pn) (n-1))</code></pre>
</details>
</section>
<section id="summary" class="level2">
<h2>Summary</h2>
<p>In this lecture, we saw that natural deduction can be encoded with refinement types, and specifically in Liquid Haskell. We saw that the rules of natural deduction can be encoded by the type checking rules of Liquid Haskell, where the expressions provide evidence for the rules. We saw that the Curry-Howard correspondence can be extended to higher order logic. We saw that we can prove higher order properties in Liquid Haskell.</p>
</section>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquidhaskell.goto.ucsd.edu/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
