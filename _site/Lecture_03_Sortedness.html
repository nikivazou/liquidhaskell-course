<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Liquid Haskell</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Lecture_01_RefinementTypes.html'><b>1.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.1.</b> Installation</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.2.</b> Basic Refinement Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.3.</b> Subtyping</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.4.</b> From Subtyping to Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.5.</b> Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.6.</b> Primitive Operations</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.7.</b> Function Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.8.</b> Branching and Recursion</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.9.</b> Refined Polymorphism</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.10.</b> Putting it all together: Safe Indexing</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.11.</b> Summary</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.12.</b> Further Reading</a></li>
</ul>
<li><a href='Lecture_02_DataTypes.html'><b>2.</b>Data Types</a></li>
<ul class='section'>
<li><a href='Lecture_02_DataTypes.html#'><b>2.1.</b> Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.2.</b> Multiple Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.3.</b> Recursive Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.4.</b> Higher-Order Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.5.</b> Folding (Indexed Lists)</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.6.</b> Data Invariants: Sparse Vectors</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.7.</b> Ordered Lists</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_03_Sortedness.html'><b>3.</b>Sortedness &amp; Abstract Refinements</a></li>
<ul class='section'>
<li><a href='Lecture_03_Sortedness.html#'><b>3.1.</b> Ordered Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.2.</b> Abstraction over Sortedness</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.3.</b> Haskell's Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.4.</b> Dependent Pairs</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_04_Termination.html'><b>4.</b>Termination</a></li>
<ul class='section'>
<li><a href='Lecture_04_Termination.html#'><b>4.1.</b> Termination Requires Refinements!</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.2.</b> Termination Metrics</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.3.</b> Lexicographic Termination</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.4.</b> The GCD Example</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.5.</b> Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.6.</b> User Defined Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.7.</b> Mutual Recursion</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_05_ProofsPrograms.html'><b>5.</b>Programs are Proofs</a></li>
<ul class='section'>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.1.</b> Each Program Proves its type</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.2.</b> Propositions as Refinement Types</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.3.</b> Quantified Theorems</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.4.</b> Theorems about Haskell Functions</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.5.</b> Reusing Proofs, the "because" combinator</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.6.</b> Quantified Proofs</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.7.</b> Monotonicity of the Fibonacci Function</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.8.</b> Generalizing the Monotonicity Proof</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.9.</b> Proofs By Natural Induction</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.10.</b> Summary</a></li>
</ul>
<li><a href='Lecture_06_StructuralInduction.html'><b>6.</b>Structural Induction</a></li>
<ul class='section'>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.1.</b> Structural Induction on Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.2.</b> Map Fusion</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.3.</b> Monoid Laws for Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.4.</b> Using Proved Lemma</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_07_CaseStudyMapReduce.html'><b>7.</b>Case Study: Map Reduce</a></li>
<ul class='section'>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.1.</b> Map Reduce Explained</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.2.</b> Map Reduce "Library" Functions:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.3.</b> Map Reduce "Client" Functions: Summing a List</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.4.</b> Proving Code Equivalence: <code>sum</code> and <code>psum</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.5.</b> Chunk Definition:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.6.</b> Higher Order Theorem: <code>mRTheorem</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.7.</b> Lemmata for <code>mRTheorem</code> on plus</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.8.</b> Summary</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.9.</b> Appendix: List Manipulation Functions</a></li>
</ul>
<li><a href='Lecture_08_NaturalDeduction.html'><b>8.</b>Natural Deduction</a></li>
<ul class='section'>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.1.</b> Logical Properties</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.2.</b> Native Terms</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.3.</b> Conjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.4.</b> Disjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.5.</b> Implication &amp; Negation</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.6.</b> Forall and Exists</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.7.</b> Examples</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_09_DataPropositions.html'><b>9.</b>Data Propositions</a></li>
<ul class='section'>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.1.</b> Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.2.</b> Construction of Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.3.</b> Functions on Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.4.</b> Metatheory of Programming Languages</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.5.</b> Evaluation of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.6.</b> Typing of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.7.</b> Soundness = Progress + Preservation</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.8.</b> Summary</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.9.</b> Appendix: The rest of the Code</a></li>
</ul>
<li><a href='Task1.html'><b>10.</b>Task 1: Program Verification</a></li>
<ul class='section'>
</ul>
<li><a href='Task1.pretty.html'><b>11.</b>Task 1: Program Verification</a></li>
<ul class='section'>
<li><a href='Task1.pretty.html#'><b>11.1.</b> 1. Lists</a></li>
<li><a href='Task1.pretty.html#'><b>11.2.</b> 2. Insertion Sort</a></li>
<li><a href='Task1.pretty.html#'><b>11.3.</b> 3. Merge Sort</a></li>
</ul>
<li><a href='Task1All.html'><b>12.</b>Task 1: Program Verification</a></li>
<ul class='section'>
</ul>
<li><a href='Task2.html'><b>13.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2.html#'><b>13.1.</b> 1. Fusions</a></li>
</ul>
<li><a href='Task2.pretty.html'><b>14.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2.pretty.html#'><b>14.1.</b> 1. Fusions</a></li>
<li><a href='Task2.pretty.html#'><b>14.2.</b> 2. Higher Order Properties</a></li>
<li><a href='Task2.pretty.html#'><b>14.3.</b> 3. Encoding of Logical Properties</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="sortedness-abstract-refinements" class="level1">
<h1>Sortedness &amp; Abstract Refinements</h1>
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{- OPTIONS_GHC -fplugin=LiquidHaskell #-}
{-@ LIQUID "--no-termination" @-}
module Lecture_03_Sortedness where

main :: IO ()
main = return ()</div>
</div>

<section id="ordered-lists" class="level2">
<h2>Ordered Lists</h2>
<p>Last time we saw that we can use refinement types on the data type definitions to specify <em>invariants</em> about the data types. Today we will use this invariant to specify <em>sortedness</em> of lists.</p>
<p>Here’s a type for sequences that mimics the classical list:</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">data IncList a =
    Emp
  | (:<) { hd :: a, tl :: IncList a }

infixr 9 :<</div>
</div>

<p> The Haskell type above does not state that the elements are in order of course, but we can specify that requirement by refining <em>every</em> element in <code>tl</code> to be <em>greater than</em> <code>hd</code>:</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ data IncList a =
        Emp
      | (:<) { hd :: a, tl :: IncList {v:a | hd <= v}}  @-}</div>
</div>

<p><br />
<strong>Refined Data Constructors</strong> Once again, the refined data definition is internally converted into a “smart” refined data constructor</p>
<pre class="spec"><code>-- Generated Internal representation
data IncList a where
  Emp  :: IncList a
  (:&lt;) :: hd:a -&gt; tl:IncList {v:a | hd &lt;= v} -&gt; IncList a</code></pre>
<p>which ensures that we can only create legal ordered lists.</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">okList :: IncList Int
okList  = 1 :< 2 :< 3 :< Emp      -- accepted by LH

badList :: IncList Int
badList = 2 :< 1 :< 3 :< Emp      -- rejected by LH</div>
</div>

<p> It’s all very well to <em>specify</em> ordered lists. Next, let’s see how it’s equally easy to <em>establish</em> these invariants by implementing several textbook sorting routines.</p>
<p>First, let’s implement <a href="https://en.wikipedia.org/wiki/Insertion_sort#/media/File:Insertion-sort-example-300px.gif">insertion sort</a>, which converts an ordinary list <code>[a]</code> into an ordered list <code>IncList a</code>.</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">insertSort        :: (Ord a) => [a] -> IncList a
insertSort []     = Emp
insertSort (x:xs) = iinsert x (insertSort xs)</div>
</div>

<p>The hard work is done by <code>insert</code> which places an element into the correct position of a sorted list. LiquidHaskell infers that if you give <code>insert</code> an element and a sorted list, it returns a sorted list.</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">iinsert             :: (Ord a) => a -> IncList a -> IncList a
iinsert y Emp       = y :< Emp
iinsert y (x :< xs) = undefined </div>
</div>

<p><strong>Question:</strong> What should be the definition of <code>iinsert</code>?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The function <code>iinsert</code> can be defined as follows: </em>
</p>
<pre class="spec"><code>iinsert             :: (Ord a) =&gt; a -&gt; IncList a -&gt; IncList a
iinsert y Emp       = y :&lt; Emp
iinsert y (x :&lt; xs) | y &lt;= x    = y :&lt; x :&lt; xs 
                    | otherwise = x :&lt; iinsert y xs </code></pre>
</details>
<p><strong>Question:</strong> Can you update the definition of <code>insertSort</code> to use <code>foldr</code>?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The updated definition of <code>insertSort</code> using <code>foldr</code> is as follows: </em>
</p>
<pre class="spec"><code>insertSort    :: (Ord a) =&gt; [a] -&gt; IncList a
insertSort xs = foldr iinsert Emp xs</code></pre>
</details>
<p><strong>Question:</strong> What do you need to do to define insertion of decreasing lists?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>First you need to define a data type for decreasing lists. Next, adjust the definition of the sorting function to construct the new type.</em>
</p>
</details>
</section>
<section id="abstraction-over-sortedness" class="level2">
<h2>Abstraction over Sortedness</h2>
<p>Ideally, we would like to write a verified sorted function that works for various sortedness properties and even over Haskell’s lists. Of course, we cannot constraint all lists to be sorted. But, we can abstract the notion of sortedness over the data declaration.</p>
<p>Thus, instead of explicitly stating that the head should be less that the element of the tail:</p>
<pre class=".{spec}"><code>{-@ data IncList a = 
         Emp
      | (:&lt;) { hd :: a, tl :: IncList {v:a | hd &lt;= v}}  @-}</code></pre>
<p>We say that there exists a predicate <code>p</code> that relates the head and all elements of the tail:</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">data PList a = Nil | Cons a (PList a)

{-@ data PList a < p :: a -> a -> Bool> = 
        Nil
      | Cons { phd :: a, ptl :: PList < p >  a < p phd > }  @-}</div>
</div>

<p><strong>Refined Data Constructors</strong> The internal data constructors are refined to be parametric with respect to the predicate <code>p</code>:</p>
<pre class="spec"><code>-- Generated Internal representation
data PncList a where
  Nil  :: IncList a
  Cons :: forall a, p. hd:a -&gt; tl:PList &lt;p&gt; {v:a | p hd} -&gt; PList &lt;p&gt; a</code></pre>
<p>Now this abstract predicate can be instantiated with different properties:</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ type IPList a = PList <{\hd v -> hd <= v}> a  @-}
{-@ type DPList a = PList <{\hd v -> hd >= v}> a  @-}
{-@ type EPList a = PList <{\hd v -> hd == v}> a  @-}

pl1, pl2, pl3, pl4 :: PList Int 

pl1 = Cons 1 (Cons 2 (Cons 3 Nil))
pl2 = Cons 3 (Cons 2 (Cons 1 Nil))
pl3 = Cons 1 (Cons 1 (Cons 1 Nil))
pl4 = Nil</div>
</div>

<p><strong>Question:</strong> Give refinement types to the above four lists.</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The list <code>pl1</code> is increasing, <code>pl2</code> is decreasing, <code>pl3</code> is equal and <code>pl4</code> is empty, which means that it could have any property.</em>
</p>
<pre class="spec"><code>{-@ pl1 :: IPList Int @-}
{-@ pl2 :: DPList Int @-}
{-@ pl3 :: EPList Int @-}
{-@ pl4 :: IPList Int @-}</code></pre>
</details>
<p>So, now the same Haskell lists can be refined to be either decreasing, increasing or equal. For example, the code below inserts into an increasing list:</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ pinsert         :: (Ord a) => a -> IPList a -> IPList a @-}
pinsert             :: (Ord a) => a -> PList a -> PList a
pinsert y Nil       = y `Cons` Nil
pinsert y (x `Cons` xs) 
  | y <= x         = y `Cons` (x `Cons` xs)
  | otherwise      = x `Cons` pinsert y xs</div>
</div>

<p><strong>Question:</strong> Can you adjust it to <code>insert</code> for decreasing lists?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>You need to 1) change the type and 2) change the guard condition:</em>
</p>
<pre class="spec"><code>{-@ pinsert         :: (Ord a) =&gt; a -&gt; DPList a -&gt; DPList a @-}
pinsert             :: (Ord a) =&gt; a -&gt; PList a -&gt; PList a
pinsert y Nil       = y `Cons` Nil
pinsert y (x `Cons` xs) 
  | y &gt;= x         = y `Cons` (x `Cons` xs)
  | otherwise      = x `Cons` pinsert y xs</code></pre>
</details>
</section>
<section id="haskells-lists" class="level2">
<h2>Haskell’s Lists</h2>
<p>Liquid Haskell comes by default with parametrized lists. So we can instantiate the refinements over Haskell’s lists directly.</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">{-@ type IList a = [a]<{\hd v -> (v >= hd)}>  @-}
{-@ type DList a = [a]<{\hd v -> (v <= hd)}>  @-}
{-@ type EList a = [a]<{\hd v -> (v == hd)}>  @-}

ilist, dlist, elist :: [Int] 

{-@ ilist :: IList Int @-}
ilist = [1, 2, 3]
    
{-@ dlist :: DList Int @-}
dlist = [3, 2, 1]

{-@ elist :: EList Int @-}
elist = [1, 1, 1]</div>
</div>

<p>With these definitions, we can verify insertion of elements into Haskell’s lists:</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">{-@ insert         :: (Ord a) => a -> IList a -> IList a @-}
insert             :: (Ord a) => a -> [a] -> [a]
insert y []        = [y]
insert y (x:xs) 
  | y <= x         = y:x:xs
  | otherwise      = x:insert y xs

{-@ isort :: (Ord a) => IList a -> IList a @-}
isort :: (Ord a) => [a] -> [a]
isort []     = []
isort (x:xs) = insert x (isort xs)</div>
</div>

<p><strong>Question:</strong> Let’s also check if <code>isort</code> preserves the <code>len</code> of the list. (Where <code>len</code> is the buildin measure for Haskell’s lists.)</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The updated types that ensure the length preservation are the following:</em>
</p>
<pre class="spec"><code>{-@ insert :: (Ord a) =&gt; a -&gt; x:IList a -&gt; {v:IList a | len v = len x + 1 } @-}
{-@ isort  :: (Ord a) =&gt; x:IList a -&gt; {v:IList a | len x = len v} @-}</code></pre>
</details>
<p>This abstraction, called <a href="http://goto.ucsd.edu/~rjhala/liquid/abstract_refinement_types.pdf">Abstract Refinements</a> is very powerful since it allows lists to turn from increasing to decreasing. Because of this flexibility, Liquid Haskell can automatically verify the below code, used as the official <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-List.html#v:sortBy">sorting function</a> in Haskell, that very smartly sorts lists by collecting increasing and decreasing subsequences and merging them back together.</p>
<pre class="spec"><code>{-@  sort :: (Ord a) =&gt; [a] -&gt; IList a  @-}
sort :: (Ord a) =&gt; [a] -&gt; [a]
sort xs = mergeAll (sequences xs)
  where
    sequences :: Ord a =&gt; [a] -&gt; [[a]]
    sequences (a:b:xs)
      | a `compare` b == GT = descending b [a]  xs
      | otherwise           = ascending  b (a:) xs
    sequences [x] = [[x]]
    sequences []  = [[]]

    descending :: Ord a =&gt; a -&gt; [a] -&gt; [a] -&gt; [[a]]
    descending a as (b:bs)
      | a `compare` b == GT = descending b (a:as) bs
    descending a as bs    = (a:as): sequences bs

    ascending :: Ord a =&gt; a -&gt; ([a] -&gt; [a]) -&gt; [a] -&gt; [[a]]
    ascending a as (b:bs) 
      | a `compare` b /= GT = ascending b (\ys -&gt; as (a:ys)) bs
    ascending a as bs      = as [a]: sequences bs

    mergeAll []  = [] 
    mergeAll [x] = x
    mergeAll xs  = mergeAll (mergePairs xs)

    mergePairs :: Ord a =&gt; [[a]] -&gt; [[a]]
    mergePairs (a:b:xs) = merge1 a b: mergePairs xs
    mergePairs [x]      = [x]
    mergePairs []       = []

    merge1 :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
    merge1 (a:as&#39;) (b:bs&#39;)
      | a `compare` b == GT = b:merge1 (a:as&#39;)  bs&#39;
      | otherwise           = a:merge1 as&#39; (b:bs&#39;)
    merge1 [] bs            = bs
    merge1 as []            = as</code></pre>
</section>
<section id="dependent-pairs" class="level2">
<h2>Dependent Pairs</h2>
<p>Liquid Haskell has one more build in abstraction for pairs. So, internally the pairs are representing using abstract refinements as :</p>
<pre class="spec"><code>data Pair a b &lt; p :: a -&gt; b&gt; = P {fst :: a, snd :: b &lt; p fst&gt; }</code></pre>
<p>The generated type is also parametric:</p>
<pre class="spec"><code>-- Generated Internal representation
(,) :: forall a b &lt;p :: a -&gt; b&gt;. x:a -&gt; b &lt;p x&gt; -&gt; Pair a b &lt;p&gt;</code></pre>
<p>This allows us to specify dependent pairs, where the second element depends on the first:</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">{-@ pair1 :: (Int, Int) < {\f s -> f <= s} > @-}
pair1 :: (Int, Int)
pair1 = (2, 4)</div>
</div>

<p>So, now we can use the syntax of dependent type theory pairs to write interesting properties:</p>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">exGt :: Int -> (Int, ())
{-@ exGt :: x:Nat -> (Nat, ()) < {\f s -> f > x} > @-}
exGt x = (x+1, ())</div>
</div>

<p>The above code says that for each natural number <code>x</code>, there exists one <code>y</code> that is greater than <code>x</code>, taking us to a theorem proving territory, that we will return soon.</p>
<p><strong>Question:</strong> Is this property true for less than too?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>No, because it would encode that for every natural number, there exists a smaller natural number, which is not true. But, it is true for integers:</em>
</p>
<pre class="spec"><code>exLt :: Int -&gt; (Int, ())
{-@ exLt :: x:Int -&gt; (Int, ()) &lt; {\f s -&gt; f &lt; x} &gt; @-}
exLt x = (x-1, ())</code></pre>
</details>
</section>
<section id="summary" class="level2">
<h2>Summary</h2>
<p>We saw three ways to specify sortedness of lists:</p>
<ol type="1">
<li>By refining the data type definition,</li>
<li>By abstracting the sortedness property, and</li>
<li>By refining the list type directly.</li>
</ol>
<p>The notion of abstract refinements is very powerful. In Liquid Haskell it is also used to encode dependent pairs and can be used in user defined data structures to specify various abstract dependencies.</p>
</section>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquidhaskell.goto.ucsd.edu/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
