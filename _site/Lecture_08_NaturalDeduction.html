<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Liquid Haskell</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Lecture_01_RefinementTypes.html'><b>1.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.1.</b> Installation</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.2.</b> Basic Refinement Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.3.</b> Subtyping</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.4.</b> From Subtyping to Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.5.</b> Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.6.</b> Primitive Operations</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.7.</b> Function Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.8.</b> Branching and Recursion</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.9.</b> Refined Polymorphism</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.10.</b> Putting it all together: Safe Indexing</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.11.</b> Summary</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.12.</b> Further Reading</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.13.</b> Cheatsheet</a></li>
</ul>
<li><a href='Lecture_02_DataTypes.html'><b>2.</b>Data Types</a></li>
<ul class='section'>
<li><a href='Lecture_02_DataTypes.html#'><b>2.1.</b> Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.2.</b> Multiple Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.3.</b> Recursive Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.4.</b> Higher-Order Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.5.</b> Folding (Indexed Lists)</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.6.</b> Data Invariants: Sparse Vectors</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.7.</b> Ordered Lists</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_03_Sortedness.html'><b>3.</b>Sortedness &amp; Abstract Refinements</a></li>
<ul class='section'>
<li><a href='Lecture_03_Sortedness.html#'><b>3.1.</b> Ordered Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.2.</b> Abstraction over Sortedness</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.3.</b> Haskell's Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.4.</b> Dependent Pairs</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_04_Termination.html'><b>4.</b>Termination</a></li>
<ul class='section'>
<li><a href='Lecture_04_Termination.html#'><b>4.1.</b> Termination Requires Refinements!</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.2.</b> Termination Metrics</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.3.</b> Lexicographic Termination</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.4.</b> The GCD Example</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.5.</b> Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.6.</b> User Defined Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.7.</b> Mutual Recursion</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_05_ProofsPrograms.html'><b>5.</b>Programs are Proofs</a></li>
<ul class='section'>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.1.</b> Each Program Proves its type</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.2.</b> Propositions as Refinement Types</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.3.</b> Quantified Theorems</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.4.</b> Theorems about Haskell Functions</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.5.</b> Reusing Proofs, the "because" combinator</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.6.</b> Quantified Proofs</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.7.</b> Monotonicity of the Fibonacci Function</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.8.</b> Generalizing the Monotonicity Proof</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.9.</b> Proofs By Natural Induction</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.10.</b> Summary</a></li>
</ul>
<li><a href='Lecture_06_StructuralInduction.html'><b>6.</b>Structural Induction</a></li>
<ul class='section'>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.1.</b> Structural Induction on Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.2.</b> Map Fusion</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.3.</b> Monoid Laws for Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.4.</b> Using Proved Lemma</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_07_CaseStudyMapReduce.html'><b>7.</b>Case Study: Map Reduce</a></li>
<ul class='section'>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.1.</b> Map Reduce Explained</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.2.</b> Map Reduce "Library" Functions:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.3.</b> Map Reduce "Client" Functions: Summing a List</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.4.</b> Proving Code Equivalence: <code>sum</code> and <code>psum</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.5.</b> Chunk Definition:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.6.</b> Higher Order Theorem: <code>mRTheorem</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.7.</b> Lemmata for <code>mRTheorem</code> on plus</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.8.</b> Summary</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.9.</b> Appendix: List Manipulation Functions</a></li>
</ul>
<li><a href='Lecture_08_NaturalDeduction.html'><b>8.</b>Natural Deduction</a></li>
<ul class='section'>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.1.</b> Logical Properties</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.2.</b> Native Terms</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.3.</b> Conjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.4.</b> Disjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.5.</b> Implication</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.6.</b> Negation</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.7.</b> Forall</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.8.</b> Exists</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.9.</b> Example 1: existsAll</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.10.</b> Example 2: Distributing Qualifiers</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.11.</b> Example 3: List Properties</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.12.</b> Example 4: Natural Induction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.13.</b> Summary</a></li>
</ul>
<li><a href='Lecture_09_DataPropositions.html'><b>9.</b>Data Propositions</a></li>
<ul class='section'>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.1.</b> Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.2.</b> Construction of Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.3.</b> Functions on Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.4.</b> Metatheory of Programming Languages</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.5.</b> Evaluation of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.6.</b> Typing of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.7.</b> Soundness = Progress + Preservation</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.8.</b> Summary</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.9.</b> Appendix: The rest of the Code</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="natural-deduction" class="level1">
<h1>Natural Deduction</h1>
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{- OPTIONS_GHC -fplugin=LiquidHaskell #-}
module Lecture_08_NaturalDeduction where

{-@ LIQUID "--reflection" @-}
{-@ LIQUID "--ple"        @-}
{-@ infix ++ @-}
import Language.Haskell.Liquid.ProofCombinators
import Prelude hiding ((++))</div>
</div>

<p>In a previous lecture we saw tha programs are proofs and we proved a higher order property, i.e., a property over functions, that all increasing functions are monotonic.</p>
<p>In this lecture, we see that any higher order property can be encoded in Liquid Haskell, because refinement types can encode higher order logic and type checking can encode the natural deduction proof system.</p>
<section id="logical-properties" class="level2">
<h2>Logical Properties</h2>
<p>Like a programming language, logic has</p>
<ul>
<li><strong>syntax</strong> (<span class="math inline">\(e\)</span>, <span class="math inline">\(\land\)</span>, <span class="math inline">\(\lor\)</span>, <span class="math inline">\(\lnot\)</span>, <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\forall\)</span>, <span class="math inline">\(\exists\)</span>)</li>
<li><strong>meaning</strong> (if <span class="math inline">\(\phi\)</span> is true and <span class="math inline">\(\psi\)</span> is true, then <span class="math inline">\(\phi \land \psi\)</span> is true), and</li>
<li><strong>“evaluation”</strong> (decision procedues).</li>
</ul>
<p><strong>Natural Deduction</strong> is a decision procedure for logic. The Curry-Howard correspondence says that propositions are types and proofs are programs. In this lecture, we will see that natural deduction is encoded by type checking rules.</p>
<p>Concretely, we will see the encoding by filling in the following table:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="native-terms" class="level2">
<h2>Native Terms</h2>
<p>We start with the simplest case, native terms. We have already seen that native terms are encoded by refinements on unit types:</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">{-@ fact1 :: {v:() | 2 == 1 + 1 } @-}
fact1 :: ()
fact1 = ()

{-@ fact2 :: {v:() | 2 /= 3 } @-}
fact2 :: ()
fact2 = ()</div>
</div>

<p>So native terms are encoded by unit types with refinements:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="conjunction" class="level2">
<h2>Conjunction</h2>
<p>Conjunction is encoded by the pair type. If you know that <span class="math inline">\(\phi_1\)</span> is true and <span class="math inline">\(\phi_2\)</span> is true, then <span class="math inline">\((\phi_1, \phi_2)\)</span> is a term that shows that <span class="math inline">\(\phi_1 \land \phi_2\)</span> is true.</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ conj :: ϕ1:{Bool | ϕ1 } -> ϕ2:{Bool | ϕ2 } 
         -> {v:(Bool, Bool) | ϕ1 && ϕ2} @-}
conj :: Bool -> Bool -> (Bool, Bool)
conj ϕ1 ϕ2 = (ϕ1,ϕ2)</div>
</div>

<p>Given that logical conjunction can be encoded as pairs, we can see how type checking can encode the natural deduction proof system. When typing pairs, there are three rules: left and right <em>elimination</em> and <em>introduction</em>.</p>
<p><span class="math display">\[
\inferrule
  {\land\text{-L-E}}
  {
    \Gamma \vdash e : (\phi_1, \phi_2)
  }{
    \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_1 : \phi_1
  }
\]</span></p>
<p><span class="math display">\[
\inferrule
  {\land\text{-R-E}}
  {
    \Gamma \vdash e : (\phi_1, \phi_2)
  }{
    \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_2 : \phi_2
  }
\]</span></p>
<p><span class="math display">\[
\inferrule
  {\land\text{-I}}
  {
    \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_1 : \phi_1 \\
    \Gamma \vdash \text{case } e \text{ of } (x_1, x_2) \rightarrow x_2 : \phi_2
  }{
    \Gamma \vdash e : (\phi_1, \phi_2)
  }
\]</span></p>
<p>If we ignore the expressions above we take exactly the conjuction rules of natural deduction.</p>
<p>** You can generate Haskell terms that provide evidence for the natural deduction rules!**</p>
<p>As an example, consider the natural deduction devation below</p>
<p><span class="math display">\[
\inferrule
  {\land\text{-I}}
  {
    \phi_1,\phi_2\land\phi_3 \vdash  \phi_1  \qquad
    \inferrule{\land\text{-R-E}}
    {
      \phi_1,\phi_2\land\phi_3 \vdash  \phi_2\land\phi_3
    }{
      \phi_1,\phi_2\land\phi_3 \vdash  \phi_3
    }
  }{
    \phi_1, \phi_2\land\phi_3 \vdash  \phi_1\land \phi_3
  }
\]</span></p>
<p>Filling in the terms (and applying the correspondence of propositions and types) we get:</p>
<p><span class="math display">\[
\inferrule
  {\land\text{-I}}
  {
    x_1:\phi_1,x_{23}:\phi_2\land\phi_3 \vdash  x_1:\phi_1  \qquad
    \inferrule{\land\text{-R-E}}
    {
      x_1:\phi_1,x_{23}:\phi_2\land\phi_3 \vdash x_{23}: \phi_2\land\phi_3
    }{
      x_1:\phi_1,x_{23}:\phi_2\land\phi_3 \vdash \text{case } x_{23} \text{ of } (x_2, x_3) \rightarrow x_3: \phi_3
    }
  }{
    x_1:\phi_1,x_{23}: \phi_2\land\phi_3 \vdash (x_1, \text{case } x_{23} \text{ of } (x_2, x_3) \rightarrow x_3): \phi_1\land \phi_3
  }
\]</span></p>
<p>Let’s encode this proof in Liquid Haskell!</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">{-@ ex1 :: φ1:Bool -> φ2:Bool -> φ3:Bool 
    -> {v:() | φ1}
    -> ({v:() | φ2}, {v:() | φ3})
    -> ({v:() | φ1}, {v:() | φ3}) @-}
ex1 :: Bool -> Bool -> Bool -> () -> ((), ()) -> ((), ())
ex1 _ _ _ x1 x23 = 
  (x1, case x23 of (x2,x3) -> x3)</div>
</div>

<p>So, conjuction is encoded by the pair type.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;">{e}</td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="disjunction" class="level2">
<h2>Disjunction</h2>
<p>Disjunction is encoded by the <code>Either</code> type, which is a sum type that can be either <code>Left</code> or <code>Right</code>. <code>data Either a b = Left a | Right b</code>.</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">{-@ disj :: ϕ1:Bool -> ϕ2:Bool -> {v:() | ϕ1 || ϕ2 }
         -> {v:Either () () | ϕ1 || ϕ2 } @-}
disj :: Bool -> Bool -> () -> Either () ()
disj ϕ1 ϕ2 p = if ϕ1 then Left p else Right p</div>
</div>

<p>If you know that <span class="math inline">\(\phi_1\)</span> is true or <span class="math inline">\(\phi_2\)</span> is true, then <code>Left ()</code> is a term that shows that <span class="math inline">\(\phi_1 \lor \phi_2\)</span> is true and <code>Right ()</code> is a term that shows that <span class="math inline">\(\phi_1 \lor \phi_2\)</span> is true.</p>
<p>Dually to conjunction, disjunction has three rules: left and right <em>introduction</em> and <em>elimination</em>.</p>
<p><span class="math display">\[
\inferrule
  {\lor\text{-L-I}}
  {
    \Gamma \vdash e : \phi_1
  }{
    \Gamma \vdash \text{Left } e : \text{Either } \phi_1 \ \phi_2
  }
\]</span></p>
<p><span class="math display">\[
\inferrule
  {\lor\text{-R-I}}
  {
    \Gamma \vdash e : \phi_2
  }{
    \Gamma \vdash \text{Right } e : \text{Either } \phi_1 \ \phi_2
  }
\]</span></p>
<p><span class="math display">\[
\inferrule
  {\lor\text{-E}}
  {
    \Gamma \vdash e : \text{Either } \phi_1\ \phi_2 \\
    \Gamma, x_1 : \phi_1 \vdash e_1 : \phi \quad
    \Gamma, x_2 : \phi_2 \vdash e_2 : \phi
  }{
    \Gamma \vdash \text{case } e \text{ of } \{\text{Left } x_1 \rightarrow x_1 ;  
                                             \text{Right } x_2 \rightarrow x_2 \} : \phi
  }
\]</span></p>
<p>So, disjunction is encoded by the either type.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;">{e}</td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"> <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="implication" class="level2">
<h2>Implication</h2>
<p>Implication is encoded by the function type. It has two rules: <em>introduction</em> and <em>elimination</em>:</p>
<p><span class="math display">\[
\inferrule
  {\Rightarrow\text{-I}}
  {
    \Gamma, x : \phi_x \vdash e : \phi
  }{
    \Gamma \vdash \lambda x. e : \phi_x \rightarrow \phi
  }
\]</span></p>
<p><span class="math display">\[
\inferrule
  {\Rightarrow\text{-E}}
  {
    \Gamma \vdash e : \phi_x \rightarrow \phi \quad
    \Gamma \vdash e_x : \phi_x
  }{
    \Gamma \vdash e\ e_x : \phi
  }
\]</span></p>
<p>The Implication Elimination Rule for natural deduction is also known as the <em>modus ponens</em> rule.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;">{e}</td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"> <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \rightarrow \phi_2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="negation" class="level2">
<h2>Negation</h2>
<p>Negation is just implication to <code>False</code>.</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">{-@ neg :: ϕ:Bool -> {v:() | not ϕ} 
        -> ({v:() | ϕ} -> {v:() | false}) @-}
neg :: Bool -> () -> (() -> ())
neg _ _ = \_ -> ()</div>
</div>

<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"> <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \rightarrow \phi_2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi \rightarrow \{\text{false}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="forall" class="level2">
<h2>Forall</h2>
<p>Forall is encoded by the quantified function type. It has two rules: <em>introduction</em> and <em>elimination</em>:</p>
<p><span class="math display">\[
\inferrule
  {\forall\text{-I}}
  {
    \Gamma, x:\tau \vdash e : \phi
  }{
    \Gamma \vdash \lambda x. e : x:\tau \rightarrow \phi
  }
\]</span></p>
<p><span class="math display">\[
\inferrule
  {\forall\text{-E}}
  {
    \Gamma \vdash e : (x:\tau \rightarrow \phi) \quad
    \Gamma \vdash e_x : \tau
  }{
    \Gamma \vdash e\ e_x : \phi [x / e_x]
  }
\]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"> <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \rightarrow \phi_2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi \rightarrow \{\text{false}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x:\tau \rightarrow \phi\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="exists" class="level2">
<h2>Exists</h2>
<p>Exists is encoded by the dependent pair. It has two rules: <em>introduction</em> and <em>elimination</em>:</p>
<p><span class="math display">\[
\inferrule
  {\exists\text{-I}}
  {
    \Gamma \vdash \text{fst } e : \tau \quad
    \Gamma, x:\tau \vdash \text{snd }  e : \phi
  }{
    \Gamma \vdash e : (x:\tau, \phi[x / \text{fst } e])
  }
\]</span></p>
<p><span class="math display">\[
\inferrule
  {\exists\text{-E}}
  {
    \Gamma \vdash e : (x:\tau, \phi_x) \quad
    \Gamma, x:\tau, y:\phi_x \vdash e&#39; : \phi
  }{
    \Gamma \vdash \text{case } e \text{ of } (x, y) \rightarrow e&#39; : \phi
  }
\]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><strong>Logical Formula</strong></th>
<th style="text-align: center;"><strong>Refinement Type</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Native Terms</td>
<td style="text-align: center;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{e\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Conjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \land \phi_2\)</span></td>
<td style="text-align: center;">(<span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Disjunction</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \lor \phi_2\)</span></td>
<td style="text-align: center;"> <span class="math inline">\(\phi_1\)</span> <span class="math inline">\(\phi_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Implication</td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \Rightarrow \phi_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi_1 \rightarrow \phi_2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Negation</td>
<td style="text-align: center;"><span class="math inline">\(\lnot \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi \rightarrow \{\text{false}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">Forall</td>
<td style="text-align: center;"><span class="math inline">\(\forall x. \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x:\tau \rightarrow \phi\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Exists</td>
<td style="text-align: center;"><span class="math inline">\(\exists x. \phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\((x:\tau, \phi)\)</span></td>
</tr>
</tbody>
</table>
<p>That concludes the encoding! Let’s now see some examples that use it!</p>
</section>
<section id="example-1-existsall" class="level2">
<h2>Example 1: existsAll</h2>
<p>The first example is a proof that if there exists an <span class="math inline">\(x\)</span> that satisfies a property forall <span class="math inline">\(y\)</span>, then forall <span class="math inline">\(y\)</span> there exists an <span class="math inline">\(x\)</span> that satisfies the property.</p>
<p><span class="math display">\[ \phi = \exists x. \forall y. p\ x \ y  \Rightarrow \forall y. \exists x. p \ x \ y \]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">{-@ exAll :: p:(a -> a -> Bool)
          -> (x::a, y:a -> {v:() | p x y}) 
          -> y:a 
          -> (x::a, {v:() | p x y}) @-}
exAll :: (a -> a -> Bool) -> (a, a -> ()) -> a -> (a, ())
exAll p = undefined</div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<p>The natural deduction proof is shown below:</p>
<div id="fig:avl" style="align: left; text-align:center;">
  <img src="img/exAll.png" height="300px" style="display:block;  margin-left:auto; margin-right:auto">
  <div class="caption" style="text-align:center"><b>Figure 1.1:</b> Natural Deduction Proof for exAll </div>
</div>
<br>


</section>
<section id="example-2-distributing-qualifiers" class="level2">
<h2>Example 2: Distributing Qualifiers</h2>
<p>First, let’s distribute the exists quantifier over disjunction.</p>
<p><span class="math display">\[ \phi_\exists = (\exists x. p\ x \lor q\ x) \rightarrow ((\exists x. p\ x) \lor (\exists x. q\ x)) \]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">exDistOr = undefined </div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
<p>Now, let’s distribute the forall quantifier over conjunction.</p>
<p><span class="math display">\[ \phi_\forall = (\forall x. p\ x \land q\ x) \rightarrow ((\forall x. p\ x) \land (\forall x. q\ x))\]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">allDistAnd = undefined</div>
</div>

<p><strong>Question</strong>: Can you prove this property in Liquid Haskell?</p>
</section>
<section id="example-3-list-properties" class="level2">
<h2>Example 3: List Properties</h2>
<p>Next, let’s prove that for all lists that are constructed by appending a list to itself, there exists an integer that is half the length of the list.</p>
<p><span class="math display">\[ \phi = \forall xs. (\exists ys. xs = ys \text{ ++ } ys) \rightarrow (\exists n. \text{length } xs = n + n )\]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">evenLen = undefined</div>
</div>

<p><strong>Question</strong>: Can you prove the above property in Liquid Haskell? <em>Hint:</em> You can use the property <code>lenAppend</code>:</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">{-@ lenAppend :: xs:[a] -> ys:[a] -> {v:() | len (xs ++ ys) == len xs + len ys} @-}
lenAppend :: [a] -> [a] -> ()
lenAppend [] _      = ()
lenAppend (_:xs) ys = lenAppend xs ys

{-@ reflect ++ @-}
(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)</div>
</div>

</section>
<section id="example-4-natural-induction" class="level2">
<h2>Example 4: Natural Induction</h2>
<p>Finally, let’s prove that for all natural numbers,</p>
<p><span class="math display">\[ \phi = (p \ 0 \land (\forall n. p \ (n-1) \rightarrow p \ n))) \rightarrow \forall n. p \ n\]</span></p>
<p>Let’s prove this propery in Liquid Haskell!</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">natInd = undefined</div>
</div>

</section>
<section id="summary" class="level2">
<h2>Summary</h2>
<p>In this lecture, we saw that natural deduction can be encoded in Liquid Haskell. We saw that the rules of natural deduction can be encoded by the type checking rules of Liquid Haskell. We saw that the Curry-Howard correspondence can be extended to higher order logic. We saw that we can prove higher order properties in Liquid Haskell.</p>
</section>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquidhaskell.goto.ucsd.edu/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
