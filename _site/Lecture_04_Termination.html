<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Liquid Haskell</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Lecture_01_RefinementTypes.html'><b>1.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.1.</b> Installation</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.2.</b> Basic Refinement Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.3.</b> Subtyping</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.4.</b> From Subtyping to Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.5.</b> Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.6.</b> Primitive Operations</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.7.</b> Function Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.8.</b> Branching and Recursion</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.9.</b> Refined Polymorphism</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.10.</b> Putting it all together: Safe Indexing</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.11.</b> Summary</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.12.</b> Further Reading</a></li>
</ul>
<li><a href='Lecture_02_DataTypes.html'><b>2.</b>Data Types</a></li>
<ul class='section'>
<li><a href='Lecture_02_DataTypes.html#'><b>2.1.</b> Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.2.</b> Multiple Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.3.</b> Recursive Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.4.</b> Higher-Order Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.5.</b> Folding (Indexed Lists)</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.6.</b> Data Invariants: Sparse Vectors</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.7.</b> Ordered Lists</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_03_Sortedness.html'><b>3.</b>Sortedness &amp; Abstract Refinements</a></li>
<ul class='section'>
<li><a href='Lecture_03_Sortedness.html#'><b>3.1.</b> Ordered Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.2.</b> Abstraction over Sortedness</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.3.</b> Haskell's Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.4.</b> Dependent Pairs</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_04_Termination.html'><b>4.</b>Termination</a></li>
<ul class='section'>
<li><a href='Lecture_04_Termination.html#'><b>4.1.</b> Termination Requires Refinements!</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.2.</b> Termination Metrics</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.3.</b> Lexicographic Termination</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.4.</b> The GCD Example</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.5.</b> Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.6.</b> User Defined Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.7.</b> Mutual Recursion</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_05_ProofsPrograms.html'><b>5.</b>Programs are Proofs</a></li>
<ul class='section'>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.1.</b> Each Program Proves its type</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.2.</b> Propositions as Refinement Types</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.3.</b> Quantified Theorems</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.4.</b> Theorems about Haskell Functions</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.5.</b> Reusing Proofs, the "because" combinator</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.6.</b> Quantified Proofs</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.7.</b> Monotonicity of the Fibonacci Function</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.8.</b> Generalizing the Monotonicity Proof</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.9.</b> Proofs By Natural Induction</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.10.</b> Summary</a></li>
</ul>
<li><a href='Lecture_06_StructuralInduction.html'><b>6.</b>Structural Induction</a></li>
<ul class='section'>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.1.</b> Structural Induction on Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.2.</b> Map Fusion</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.3.</b> Monoid Laws for Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.4.</b> Using Proved Lemma</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>6.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_07_CaseStudyMapReduce.html'><b>7.</b>Case Study: Map Reduce</a></li>
<ul class='section'>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.1.</b> Map Reduce Explained</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.2.</b> Map Reduce "Library" Functions:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.3.</b> Map Reduce "Client" Functions: Summing a List</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.4.</b> Proving Code Equivalence: <code>sum</code> and <code>psum</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.5.</b> Chunk Definition:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.6.</b> Higher Order Theorem: <code>mRTheorem</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.7.</b> Lemmata for <code>mRTheorem</code> on plus</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.8.</b> Summary</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>7.9.</b> Appendix: List Manipulation Functions</a></li>
</ul>
<li><a href='Lecture_08_NaturalDeduction.html'><b>8.</b>Natural Deduction</a></li>
<ul class='section'>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.1.</b> Logical Properties</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.2.</b> Native Terms</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.3.</b> Conjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.4.</b> Disjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.5.</b> Implication &amp; Negation</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.6.</b> Forall and Exists</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.7.</b> Examples</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>8.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_09_DataPropositions.html'><b>9.</b>Data Propositions</a></li>
<ul class='section'>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.1.</b> Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.2.</b> Construction of Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.3.</b> Functions on Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.4.</b> Metatheory of Programming Languages</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.5.</b> Evaluation of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.6.</b> Typing of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.7.</b> Soundness = Progress + Preservation</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.8.</b> Summary</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>9.9.</b> Appendix: The rest of the Code</a></li>
</ul>
<li><a href='Task1.html'><b>10.</b>Task 1: Program Verification</a></li>
<ul class='section'>
</ul>
<li><a href='Task1.pretty.html'><b>11.</b>Task 1: Program Verification</a></li>
<ul class='section'>
<li><a href='Task1.pretty.html#'><b>11.1.</b> 1. Lists</a></li>
<li><a href='Task1.pretty.html#'><b>11.2.</b> 2. Insertion Sort</a></li>
<li><a href='Task1.pretty.html#'><b>11.3.</b> 3. Merge Sort</a></li>
</ul>
<li><a href='Task1All.html'><b>12.</b>Task 1: Program Verification</a></li>
<ul class='section'>
</ul>
<li><a href='Task2.html'><b>13.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2.html#'><b>13.1.</b> 1. Fusions</a></li>
</ul>
<li><a href='Task2.pretty.html'><b>14.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2.pretty.html#'><b>14.1.</b> 1. Fusions</a></li>
<li><a href='Task2.pretty.html#'><b>14.2.</b> 2. Higher Order Properties</a></li>
<li><a href='Task2.pretty.html#'><b>14.3.</b> 3. Encoding of Logical Properties</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="termination" class="level1">
<h1>Termination</h1>
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{- OPTIONS_GHC -fplugin=LiquidHaskell #-}
module Lecture_04_Termination where

import Prelude hiding (map, gcd, mod)

main :: IO ()
main = return ()</div>
</div>

<p>By default Liquid Haskell checks that every function terminates. This is required for two reasons:</p>
<ol type="1">
<li>Termination is the <em>expected behavior</em> for most functions. So, many times potential non-termination is a bug.</li>
<li>Termination is <em>required</em> for the <a href="https://dl.acm.org/doi/10.1145/2628136.2628161">soundness</a> of the type system.</li>
</ol>
<p>Up to now, we were deactivating the termination checker with the <code>--no-termination</code> flag or with the <code>lazy</code> annotation. Now, we will see how to prove termination in cases where Liquid Haskell cannot do it automatically.</p>
<section id="termination-requires-refinements" class="level2">
<h2>Termination Requires Refinements!</h2>
<p>We start with the known fibonacci function.</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">{-@ fib :: i:Int -> Int  @-}
fib :: Int -> Int
fib i | i == 0    = 0 
      | i == 1    = 1 
      | otherwise = fib (i-1) + fib (i-2)</div>
</div>

<p>Liquid Haskell will create an error in the above definition, even though it does not violate any refinement type specification.</p>
<p><em>This is a termination error</em> and it will disappear if we turn off termination checking (either with <code>--no-termination</code> pragma or with <code>{-@ lazy fib@-}</code> annotation).</p>
<p><strong>Question:</strong> Does <code>fib</code> terminate?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>Yes, but only when the input is a natural number. This would also require the result of <code>fib</code> to be a natural number. Thus, to ensure termination you need the following specification of <code>fib</code>:</em>
</p>
<pre class="spec"><code>{-@ fib :: i:Nat -&gt; Nat  @-}</code></pre>
</details>
<p>To ensure <code>fib</code> terminates we need to restrict the input to be non-negative. This is actually implied by the error message that requires the recursive argument to be <code>0 &lt;= v</code> and <code>v &lt; i</code>.</p>
<p>This error was generated because Liquid Haskell was trying to prove termination of the function <code>fib</code> by applying its termination heuristic.</p>
<p><em>Termination Heuristic:</em> The first argument that can be “sized”, i.e., turned into <code>Nat</code>, should be decreasing in recursive calls and non negative.</p>
<p><code>Int</code> is by default “size” while later we will see how to make other types “sized”.</p>
</section>
<section id="termination-metrics" class="level2">
<h2>Termination Metrics</h2>
<p>The heuristic fails in many cases. For example, consider the function <code>range</code> that generates a list of integers from <code>lo</code> to <code>hi</code>.</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ range :: lo:Int -> hi:Int -> [Int] @-} 
range :: Int -> Int -> [Int]
range lo hi
 | lo < hi = lo : range (lo+1) hi
 | otherwise = []</div>
</div>

<p><strong>Question:</strong> Does <code>range</code> terminate?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>Yes, because the difference <code>hi - lo</code> is decreasing in recursive calls. Thus, to ensure termination you need the following specification of <code>range</code>:</em>
</p>
<pre class="spec"><code>{-@ range :: lo:Int -&gt; hi:Int -&gt; [Int] / [hi - lo] @-} </code></pre>
</details>
<p>The termination heuristic fails because the first argument is not decreasing in recursive calls. To specify that the value <code>hi - lo</code> is decreasing we need to introduce a termination metric:</p>
<pre class=".{spec}"><code>{-@ range :: lo:Int -&gt; hi:Int -&gt; [Int] / [hi - lo]@-} </code></pre>
<p>Termination metrics are integer expressions that can depend on the function arguments and once provided, Liquid Haskell will use them to check termination. Concretely, at each recursive call it will check that the termination metric is both decreasing and non-negative.</p>
</section>
<section id="lexicographic-termination" class="level2">
<h2>Lexicographic Termination</h2>
<p>Many times a single natural number is not enough to specify termination. For example, consider the ackermann function:</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">{-@ ack :: m:Int -> n:Int -> Int  @-} 
ack :: Int -> Int -> Int
ack m n
  | m == 0 = n + 1
  | n == 0 = ack (m-1) 1
  | otherwise = ack (m-1) (ack m (n-1))</div>
</div>

<p><strong>Question:</strong> Does <code>ack</code> terminate?</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>Yes, because either <code>m</code> is decreasing, or <code>m</code> is the same and <code>n</code> is decreasing. This is a lexicographic termination metric and can be encoded as <code>[m,n]</code>. But, we need to ensure that <code>m</code> and <code>n</code> are non-negative, which in turn requires the result of <code>ack</code> to be non-negative. Thus, to ensure termination you need the following specification of <code>ack</code>:</em>
</p>
<pre class="spec"><code>{-@ ack :: m:Nat -&gt; n:Nat -&gt; Nat  / [m, n] @-} </code></pre>
</details>
<p>To show that <code>ack</code> terminates we need to provide a lexicographic termination metric. Now at each recursive call, Liquid Haskell will check that the first component of the metric is decreasing and if it is equal, it will check the second component, etc.</p>
</section>
<section id="the-gcd-example" class="level2">
<h2>The GCD Example</h2>
<p>The Greater Common Divisor (gcd) function is an interesting example, because it might or not require lexicographic termination.</p>
<p>The gcd of two numbers (which is not both zero) is the largest positive integer that divides both numbers. For example, the gcd of 8 and 12 is 4.</p>
<ul>
<li><strong>GCD with Lexicographic Termination:</strong></li>
</ul>
<p>The <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a> for computing the gcd of two numbers is based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number:</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">{-@ gcd :: a:Int -> b:Int -> Int @-}
gcd :: Int -> Int -> Int
gcd 0 b = 0 
gcd a 0 = a 
gcd a b | a == b = a
        | a >  b = gcd (a - b) b 
        | a <  b = gcd a (b - a) </div>
</div>

<p>For example, <code>gcd 8 12 = gcd 8 4 = gcd 4 4 = 4</code>.</p>
<strong>Question:</strong> Provide the proper lexicographic termination metric for the below <code>gcd</code> function.
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The metric is <code>[a,b]</code>. Either <code>a</code> is decreasing or it remains the same and <code>b</code> is decreasing. Thus, to ensure termination you need the following specification of <code>gcd</code>:</em>
</p>
<pre class="spec"><code>{-@ gcd :: a:Nat -&gt; b:Nat -&gt; Nat / [a, b]@-}</code></pre>
</details>
<ul>
<li><strong>GCD with Semantic Termination:</strong></li>
</ul>
<p>An alternative definition of <code>gcd</code> is using the modulo operator. Instead of directly use the difference of the two numbers, <code>ghc a b</code> is using the <code>mod</code> to remove from <code>a</code> as many <code>b</code>s as possible:</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">{-@ gcdMod :: a:Nat -> b:Nat -> Int @-}
gcdMod :: Int -> Int -> Int
gcdMod a 0 = a
gcdMod a b = gcdMod b (a `mod` b)


{-@ mod :: a:Nat -> b:Nat -> Nat @-}
mod :: Int -> Int -> Int
mod a b
  | a < b = a
  | otherwise = mod (a - b) b</div>
</div>

<p>For example, <code>gcdMod 12 8 = gcdMod 8 4 = gcdMod 4 0 = 4</code>, because <code>mod 12 8 = 4</code> and <code>mod 8 4 = 0</code>.</p>
<p>Interestingly, termination does not require any explicit metrics, but follows from the semantics of the functions. That means, that if you properly refine the functions, termination will be guaranteed.</p>
<strong>Question:</strong> Refine properly the <code>gcd</code> and <code>mod</code> functions to ensure termination.
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>Termination is ensured by the following specifications:</em>
</p>
<pre class="spec"><code>{-@ gcdMod :: a:Nat -&gt; b:{Nat | b &lt; a} -&gt; Nat @-}
{-@ mod :: a:Nat -&gt; b:{Nat | b /= 0} -&gt; {v:Nat | v &lt; b} @-}</code></pre>
</details>
</section>
<section id="data-types" class="level2">
<h2>Data Types</h2>
<p>When recursive functions are defined on data types, Liquid Haskell will first look for <em>structural termination</em>, meaning that the recursive calls are on a structural subpart of the input. For example, the <code>map</code> definition below terminates because <code>xs</code> is a subpart of <code>x:xs</code>.</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">{-@ map :: (a -> b) -> xs:[a] -> [b]  @-}
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs </div>
</div>

<p>Of course, not all recursive functions on data types are structurally terminating. As an example consider the <code>merge</code> function below, that is usually part of <a href="https://en.wikipedia.org/wiki/Merge_sort">merge sort</a> algorithm.</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ merge :: xs:[a] -> ys:[a] -> [a] @-}
merge :: Ord a => [a] -> [a] -> [a]
merge xs []   = xs
merge [] ys   = ys
merge (x:xs) (y:ys) 
  | x < y     = x:(merge xs (y:ys))
  | otherwise = y:(merge ys (x:xs))</div>
</div>

<p><strong>Question:</strong> Let’s prove <code>merge</code> terminating using a termination metric.</p>
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>Termination is ensured by the following specifications:</em>
</p>
<pre class="spec"><code>{-@ merge :: xs:[a] -&gt; ys:[a] -&gt; [a] / [len xs + len ys]@-}</code></pre>
</details>
<p><strong>Question:</strong> Let’s also show that <code>merge</code> propagates sortedness, by refining the inputs and output to be IList:</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ type IList a = [a]<{\h t -> h <= t}>  @-}</div>
</div>

<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>Sortedness is ensured by the following specifications:</em>
</p>
<pre class="spec"><code>{-@ merge :: xs:IList a -&gt; ys:IList a -&gt; IList a / [len xs + len ys]@-}</code></pre>
</details>
</section>
<section id="user-defined-data-types" class="level2">
<h2>User Defined Data Types</h2>
<p>In user defined data types, Liquid Haskell tries to prove structural termination. For example, mapping over a list defined as a user defined data type will not require a termination metric.</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">data List  a = Nil | Cons a (List a) 

lmap :: (a -> b) -> List a -> List b
lmap _ Nil         = Nil
lmap f (Cons x xs) = Cons (f x) (lmap f xs)</div>
</div>

<p>The user can provide a <em>size</em> for each user defined data type. Here, for example, we define the size of a <code>List</code> to be the length of the list.</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">{-@ data List [llen]  @-}

{-@ measure llen @-}
{-@ llen :: List a -> Nat @-}
llen :: List a -> Int 
llen Nil = 0 
llen (Cons _ xs) = 1 + llen xs </div>
</div>

<p>Now, when structural termination fails, Liquid Haskell will use the size of the data type to check termination. For example, note the termination error provided in the <code>lmerge</code> function below.</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">lmerge :: Ord a => List a -> List a -> List a 
lmerge xs Nil = xs
lmerge Nil ys = ys 
lmerge (Cons x xs) (Cons y ys) 
  | x < y     = Cons x (lmerge xs (Cons y ys))
  | otherwise = Cons y (lmerge (Cons x xs) ys)</div>
</div>

<p>Like with the Haskell’s lists, to ensure termination we need to provide a termination metric. In this case, the termination metric is the size of the <code>List</code> data type:</p>
<pre class="spec"><code>{-@ lmerge :: xs:List a -&gt; ys:List a -&gt; List a / [llen xs + llen ys] @-}</code></pre>
</section>
<section id="mutual-recursion" class="level2">
<h2>Mutual Recursion</h2>
<p>Two functions are mutually recursive if they call each other. In such cases, Liquid Haskell will not attempt to prove termination automatically. Instead, the user needs to provide termination metrics. For example, consider the <code>isEven</code> and <code>isOdd</code> functions below.</p>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">{-@ isEven :: n:Nat -> Bool @-}
{-@ isOdd  :: m:Nat -> Bool @-}

isEven :: Int -> Bool
isEven 0 = True
isEven n = isOdd (n-1)

isOdd :: Int -> Bool
isOdd m = not $ isEven m</div>
</div>

<strong>Question:</strong> Provide the proper termination metrics for the <code>isEven</code> and <code>isOdd</code> functions.
<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The termination metrics can be the following:</em>
</p>
<pre class="spec"><code>{-@ isEven :: n:Nat -&gt; Bool / [n, 0]@-}
{-@ isOdd  :: m:Nat -&gt; Bool / [m, 1]@-}</code></pre>
</details>
<p>Note that at the definition of <code>isOdd m</code>, the recursive argument remains the same. Thus, <em>something</em> should decrease! We define the termination metric <code>[m, 1]</code> for <code>isOdd</code> to ensure that the second component is decreasing. In the definition of <code>isEven n</code>, the recursive argument decreases, so the second component of the termination metric is irrelevant.</p>
<p>This pattern of providing numeric values for lexicographic termination metrics appears very often in mutually recursive functions. For example, the below code is a simplification of a real world example and follows the same pattern.</p>
<p><strong>Question:</strong> Provide the proper termination metrics for the <code>eval</code> and <code>evalAnd</code> functions?</p>
<div id="program-pane-13" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-13" class="programbox">
data BExpr = Const Bool | And BExpr BExpr

{-@ measure size @-}
size :: BExpr -> Int
{-@ size :: BExpr -> Nat @-}
size (Const _)   = 0
size (And e1 e2) = 1 + size e1 + size e2

{-@ eval :: e:BExpr -> Bool @-}
eval :: BExpr ->  Bool
eval (Const b)   = b
eval (And b1 b2) = evalAnd b2 (eval b1)

{-@ evalAnd :: e:BExpr -> Bool -> Bool  @-}
evalAnd :: BExpr -> Bool -> Bool
evalAnd b2 x1 = if x1 then (eval b2) else False </div>
</div>

<details>
<summary>
<strong>Solution</strong>
</summary>
<p>
<em>The termination metrics can be the following:</em>
</p>
<pre class="spec"><code>{-@ eval :: e:BExpr -&gt; Bool / [size e, 0] @-}
{-@ evalAnd :: e:BExpr -&gt; Bool -&gt; Bool / [size e, 1] @-}</code></pre>
</details>
</section>
<section id="summary" class="level2">
<h2>Summary</h2>
<p>Liquid Haskell, by default, checks that every function terminates. It has three mechanisms to prove termination:</p>
<ol type="1">
<li><em>Structural Termination</em>: for recursive functions on data types, Liquid Haskell will check that the recursive calls are on a subpart of the input. If this check fails, either because the function is not defined on a data type or because the recursive calls are not on a subpart of the input, then there are two more mechanisms.</li>
<li><em>Termination Heuristic</em>: the first argument that can be “sized” should be decreasing and non negative in recursive calls.</li>
<li><em>Termination Metrics</em>: user provided, integer expressions that can depend on the function arguments and are used to check termination.</li>
</ol>
<p>The <code>--no-termination</code> flag or the <code>{-@ lazy @-}</code> annotation can be used to deactivate the termination checker, either because the user is not willing to prove termination or because the functions are intentionally non-terminating.</p>
</section>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquidhaskell.goto.ucsd.edu/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
